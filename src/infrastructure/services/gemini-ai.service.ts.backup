import { Injectable, Inject } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { google } from '@ai-sdk/google';
import { streamText, type CoreTool, type LanguageModel, type CoreMessage, type ToolCallPart } from 'ai';
import { z } from 'zod';
import { User } from '../../domain/entities/user.entity';
import { AIService } from '../../domain/services/ai.service';
import { VirtualAssistanceService } from '../../domain/services/virtual-assistance.service';
import { ReportService } from '../../application/services/report.service';
import { randomUUID } from 'crypto';
import { CacheService } from '../../application/services/cache.service';

@Injectable()
export class GeminiAIService implements AIService {
  private readonly model: LanguageModel;
  private readonly apiBaseUrl: string;

  constructor(
    private readonly configService: ConfigService,
    @Inject('VirtualAssistanceService') private readonly virtualAssistanceService: VirtualAssistanceService,
    private readonly cacheService: CacheService,
    ) {
    process.env.GOOGLE_GENERATIVE_AI_API_KEY = this.configService.get<string>('GOOGLE_GENERATIVE_AI_API_KEY');
    this.model = google('gemini-1.5-flash-latest');
    const configuredBaseUrl = this.configService.get<string>('API_BASE_URL');
    const renderExternalUrl = process.env.RENDER_EXTERNAL_URL;
    this.apiBaseUrl = configuredBaseUrl || renderExternalUrl || 'http://localhost:3001';
  }

  // This method is deprecated and will be replaced by the tool-calling logic.
  // We keep it for now to avoid breaking changes, but it should be removed later.
  async generateResponse(userMessage: string, userData: User | User[]): Promise<string> {
    const systemPrompt = Array.isArray(userData)
      ? this.buildSystemPromptForMultipleUsers(userData)
      : this.buildSystemPrompt(userData);
    
    const { text } = await streamText({
      model: this.model,
      system: systemPrompt,
      prompt: userMessage,
    });

    return text;
  }
  
  async processToolCall(actor: User, userMessage: string, availableTools: Record<string, CoreTool>): Promise<string> {
    // Buscar histórico de conversa do cache
    const conversationKey = `conversation_${actor.cpf}`;
    const existingMessages: CoreMessage[] = this.cacheService.get(conversationKey) || [];
    
    // Adicionar nova mensagem do usuário
    const messages: CoreMessage[] = [...existingMessages, { role: 'user', content: userMessage }];
    
    // Limitar histórico para evitar contexto muito grande (últimas 10 mensagens)
    const trimmedMessages = messages.slice(-10);

    const result = await streamText({
      model: this.model,
      system: this.getToolCallSystemPrompt(actor),
      messages: trimmedMessages,
      tools: availableTools,
    });

    // The AI SDK stream returns tool calls and text in separate parts.
    let textContent = '';
    const toolCalls: ToolCallPart[] = [];

    try {
      for await (const part of result.fullStream) {
        if (part.type === 'text-delta') {
          textContent += part.textDelta;
        } else if (part.type === 'tool-call') {
          toolCalls.push(part);
        } else if (part.type === 'error') {
          console.error(`Stream error:`, part.error);
          throw new Error(`Stream error: ${JSON.stringify(part.error)}`);
        }
      }
    } catch (error) {
      console.error(`Error reading stream:`, error);
      throw error;
    }

    // If the model decides to call tools, we execute them and send the results back
    if (toolCalls.length > 0) {
      trimmedMessages.push({ role: 'assistant', content: toolCalls });

      const toolResults = await Promise.all(
        toolCalls.map(async (toolCall) => {
          const result = await this.executeTool(toolCall);
          return {
            type: 'tool-result' as const,
            toolCallId: toolCall.toolCallId,
            toolName: toolCall.toolName,
            result,
          };
        }),
      );

      trimmedMessages.push({ role: 'tool', content: toolResults });

      // We send the full conversation history back to the AI, including the tool results
      let finalResponseText = '';
      try {
        const finalResult = await streamText({
          model: this.model,
          system: this.getToolCallSystemPrompt(actor),
          messages: trimmedMessages,
        });
        for await (const part of finalResult.fullStream) {
          if (part.type === 'text-delta') {
            finalResponseText += part.textDelta;
          } else if (part.type === 'error') {
            console.error('Final stream error:', part.error);
          }
        }
      } catch (err) {
        console.error('[AI] Error generating final response after tool results:', err);
      }
      // Fallback: if the model didn't produce any text, synthesize a concise human response from the tool results
      if (!finalResponseText || finalResponseText.trim().length === 0) {
        console.warn('[AI] Empty final response text after tool calls. Building fallback response.');
        finalResponseText = this.buildFallbackResponseFromToolResults(toolResults);
      }

      // Salvar conversa completa no cache (com ferramentas)
      const updatedMessages = [
        ...trimmedMessages,
        { role: 'assistant', content: finalResponseText }
      ];
      this.cacheService.set(conversationKey, updatedMessages, 3600000); // Cache por 1 hora (sessão)
      
      return finalResponseText;
    }

    // Se nenhuma ferramenta foi chamada, salvamos a conversa simples
    const updatedMessages = [
      ...trimmedMessages,
      { role: 'assistant', content: textContent }
    ];
    this.cacheService.set(conversationKey, updatedMessages, 3600000); // Cache por 1 hora (sessão)
    
    return textContent;
  }

  // Build a concise human-friendly response from tool results when the model doesn't emit text
  private buildFallbackResponseFromToolResults(toolResults: Array<{ toolName: string; result: any }>): string {
    try {
      const lines: string[] = [];
      for (const tr of toolResults) {
        const name = tr.toolName;
        const result = tr.result;
        if (name === 'generateReport') {
          if (result && typeof result === 'object' && result.downloadUrl) {
            lines.push(`Relatório gerado. Link para download: ${result.downloadUrl}`);
          } else if (result && result.error) {
            lines.push(`Não foi possível gerar o relatório: ${result.error}`);
          }
          continue;
        }

        if (name === 'findPersonByName') {
          if (result && typeof result === 'object' && result.name) {
            lines.push(`Pessoa encontrada: ${result.name}`);
          } else if (result && result.error) {
            lines.push(`${result.error}`);
          }
          continue;
        }

        // Data-fetching tools
        if (Array.isArray(result)) {
          const count = result.length;
          const preview = this.previewArray(result);
          const label = this.labelForTool(name, count);
          lines.push(`${label}: ${count} encontrado(s).${preview ? `\n${preview}` : ''}`);
          continue;
        }

        if (result && typeof result === 'object') {
          const formatted = this.previewObject(result);
          const label = this.labelForTool(name, 1);
          lines.push(`${label}:\n${formatted}`);
          continue;
        }

        // Primitive or unknown
        if (result != null) {
          lines.push(String(result));
        }
      }

      if (lines.length === 0) {
        return 'Consegui obter os dados solicitados, mas não recebi um texto final da IA. Você pode pedir para eu gerar um relatório em PDF/CSV/TXT ou fazer outra pergunta.';
      }

      return lines.join('\n\n');
    } catch (err) {
      console.error('[AI] Error building fallback response:', err);
      return 'Consegui executar as ferramentas, mas não recebi um texto final da IA. Tente repetir a pergunta ou pedir um relatório.';
    }
  }

  private labelForTool(toolName: string, count: number): string {
    switch (toolName) {
      case 'getCoordinatorsOngoingActivities':
        return 'Atividades em andamento';
      case 'getCoordinatorsProfessionals':
        return 'Profissionais supervisionados';
      case 'getCoordinatorsStudents':
        return 'Estudantes supervisionados';
      case 'getCoordinatorDetails':
        return 'Detalhes do coordenador';
      case 'getStudentsScheduledActivities':
        return 'Suas atividades agendadas';
      case 'getStudentsProfessionals':
        return 'Seus preceptores';
      case 'findPersonByName':
        return 'Pessoa encontrada';
      default:
        return `Resultado (${toolName})`;
    }
  }

  private previewArray(items: any[], maxItems: number = 3): string {
    if (!items || items.length === 0) {
      return '';
    }
    const subset = items.slice(0, maxItems);
    const rendered = subset.map((item, idx) => `- ${this.previewObject(item)}`).join('\n');
    const more = items.length > maxItems ? `\n... e mais ${items.length - maxItems}.` : '';
    return `${rendered}${more}`;
  }

  private previewObject(obj: any): string {
    if (!obj || typeof obj !== 'object') {
      return String(obj);
    }
    // Try well-known shapes first
    if (obj.studentName && obj.taskName) {
      const date = new Date(obj.scheduledStartTo).toLocaleDateString('pt-BR');
      const startTime = new Date(obj.startedAt).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
      const endTime = new Date(obj.scheduledEndTo).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
      return `${obj.studentName} — ${obj.taskName} em ${obj.internshipLocationName} (${date}, ${startTime}-${endTime})`;
    }
    if (obj.taskName && obj.preceptorNames) {
      const date = new Date(obj.scheduledStartTo).toLocaleDateString('pt-BR');
      const startTime = new Date(obj.scheduledStartTo).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
      const endTime = new Date(obj.scheduledEndTo).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
      return `${obj.taskName} — ${obj.internshipLocationName} (${date}, ${startTime}-${endTime}); Preceptores: ${obj.preceptorNames.join(', ')}`;
    }
    if (obj.name && obj.email && obj.cpf) {
      const groups = obj.groupNames ? `; Grupos: ${obj.groupNames.join(', ')}` : '';
      return `${obj.name} (CPF: ${obj.cpf}); Email: ${obj.email}${groups}`;
    }
    // Generic compact rendering (first 4 keys)
    const entries = Object.entries(obj).slice(0, 4).map(([k, v]) => `${k}: ${v}`);
    return entries.join(' | ');
  }

  // Usar CacheService em vez de Map local para persistir entre requisições
  private getLastResultCacheKey(cpf: string): string {
    return `lastResult_${cpf}`;
  }

  // Cache para mapeamento nome → CPF
  private getNameToCpfCacheKey(actorCpf: string): string {
    return `nameMap_${actorCpf}`;
  }

  private cacheStudentNameMapping(actorCpf: string, students: any[]): void {
    const existingNameMap = this.cacheService.get(this.getNameToCpfCacheKey(actorCpf)) || {};
    students.forEach(student => {
      if (student.name && student.cpf) {
        existingNameMap[student.name.toLowerCase()] = student.cpf;
      }
    });
    this.cacheService.set(this.getNameToCpfCacheKey(actorCpf), existingNameMap, 3600000); // Cache por 1 hora
  }

  private cacheProfessionalNameMapping(actorCpf: string, professionals: any[]): void {
    const existingNameMap = this.cacheService.get(this.getNameToCpfCacheKey(actorCpf)) || {};
    professionals.forEach(professional => {
      if (professional.name && professional.cpf) {
        existingNameMap[professional.name.toLowerCase()] = professional.cpf;
      }
    });
    this.cacheService.set(this.getNameToCpfCacheKey(actorCpf), existingNameMap, 3600000); // Cache por 1 hora
  }

  private findCpfByName(actorCpf: string, name: string): string | null {
    const nameMap = this.cacheService.get(this.getNameToCpfCacheKey(actorCpf));
    if (nameMap) {
      return nameMap[name.toLowerCase()] || null;
    }
    return null;
  }

  // This method maps the AI's tool choice to our actual service methods.
  private async executeTool(toolCall: any): Promise<any> {
    const { toolName, args } = toolCall;
    let result: any; // To store the result of the data-fetching tools
    
    switch (toolName) {
      case 'getCoordinatorsOngoingActivities':
        result = await this.virtualAssistanceService.getCoordinatorsOngoingActivities(args.cpf);
        this.cacheService.set(this.getLastResultCacheKey(args.cpf), result, 3600000); // Cache por 1 hora (sessão)
        return result;
      case 'getCoordinatorsProfessionals':
        result = await this.virtualAssistanceService.getCoordinatorsProfessionals(args.cpf);
        this.cacheService.set(this.getLastResultCacheKey(args.cpf), result, 3600000); // Cache por 1 hora (sessão)
        // Cache mapeamento nome → CPF para profissionais
        this.cacheProfessionalNameMapping(args.cpf, result);
        return result;
      case 'getCoordinatorsStudents':
        result = await this.virtualAssistanceService.getCoordinatorsStudents(args.cpf);
        this.cacheService.set(this.getLastResultCacheKey(args.cpf), result, 3600000); // Cache por 1 hora (sessão)
        // Cache mapeamento nome → CPF para buscas futuras
        this.cacheStudentNameMapping(args.cpf, result);
        return result;
      case 'getCoordinatorDetails':
        result = await this.virtualAssistanceService.getCoordinatorDetails(args.cpf);
        this.cacheService.set(this.getLastResultCacheKey(args.cpf), result, 3600000); // Cache por 1 hora (sessão)
        return result;
      case 'getStudentsScheduledActivities':
        result = await this.virtualAssistanceService.getStudentsScheduledActivities(args.cpf);
        this.cacheService.set(this.getLastResultCacheKey(args.cpf), result, 3600000); // Cache por 1 hora (sessão)
        return result;
      case 'getStudentsProfessionals':
        result = await this.virtualAssistanceService.getStudentsProfessionals(args.cpf);
        this.cacheService.set(this.getLastResultCacheKey(args.cpf), result, 3600000); // Cache por 1 hora (sessão)
        return result;
      
      case 'findPersonByName':
        // Buscar pessoa específica por nome
        const { name: searchName, cpf: searcherCpf } = args;
        
        // Primeiro buscar em estudantes
        let allStudents: any[] = [];
        try {
          allStudents = await this.virtualAssistanceService.getCoordinatorsStudents(searcherCpf);
          this.cacheStudentNameMapping(searcherCpf, allStudents);
        } catch (error) {
          console.log('Erro ao buscar estudantes:', error);
        }
        
        let foundPerson: any = allStudents.find(student => 
          student.name.toLowerCase().includes(searchName.toLowerCase())
        );
        
        // Se não encontrou em estudantes, buscar em profissionais
        if (!foundPerson) {
          let allProfessionals: any[] = [];
          try {
            allProfessionals = await this.virtualAssistanceService.getCoordinatorsProfessionals(searcherCpf);
            this.cacheProfessionalNameMapping(searcherCpf, allProfessionals);
            
            foundPerson = allProfessionals.find(prof => 
              prof.name.toLowerCase().includes(searchName.toLowerCase())
            );
          } catch (error) {
            console.log('Erro ao buscar profissionais:', error);
          }
          
          // Se não encontrou nem em coordenador, tentar em estudante-profissionais
          if (!foundPerson) {
            try {
              const studentProfs = await this.virtualAssistanceService.getStudentsProfessionals(searcherCpf);
              foundPerson = studentProfs.find(prof => 
                prof.name.toLowerCase().includes(searchName.toLowerCase())
              );
            } catch (error) {
              console.log('Erro ao buscar student professionals:', error);
            }
          }
        }
        
        if (foundPerson) {
          // Cachear apenas os dados da pessoa encontrada para o relatório
          this.cacheService.set(this.getLastResultCacheKey(searcherCpf), [foundPerson], 3600000);
          return foundPerson;
        } else {
          return { error: `Pessoa com nome "${searchName}" não encontrada.` };
        }

      case 'generateReport':
        // The user's CPF is passed implicitly by the AI based on our prompt.
        const lastData = this.cacheService.get(this.getLastResultCacheKey(args.cpf));
        if (!lastData) {
          return { error: 'Não encontrei dados recentes para gerar um relatório. Por favor, faça uma busca primeiro.' };
        }
        
        const { format } = args;
        
        // Determinar título baseado no tipo de dados
        let title = 'Dados';
        if (Array.isArray(lastData) && lastData.length > 0) {
          if (lastData[0].studentName && lastData[0].taskName) {
            title = 'Atividades em Andamento';
          } else if (lastData[0].taskName && lastData[0].preceptorNames) {
            title = 'Atividades Agendadas';
          } else if (lastData[0].name && lastData[0].email) {
            if (lastData[0].groupNames) {
              title = 'Lista de Profissionais';
            } else {
              title = 'Lista de Estudantes';
            }
          }
        }
        
        const cacheId = randomUUID();
        this.cacheService.set(cacheId, { data: lastData, title }); // Salvar com título
        const downloadUrl = `${this.apiBaseUrl}/reports/from-cache/${cacheId}/${format}`;
        return { downloadUrl };

      default:
        return { error: 'Unknown tool' };
    }
  }

  private getToolCallSystemPrompt(actor: User): string {
    return `
      Você é um assistente virtual para a plataforma Ad-Astra.
      O usuário que está falando com você é: ${actor.name} (CPF: ${actor.cpf}, Perfil: ${actor.role}).

      REGRAS DE OURO:
      1.  **SEMPRE use o CPF do ator (${actor.cpf}) para as ferramentas, A MENOS QUE o usuário peça explicitamente por dados de OUTRA PESSOA.**
          - Exemplo: Se o coordenador (ator) pergunta "liste os alunos", use o CPF do coordenador.
          - Exemplo: Se qualquer usuário pergunta "quais minhas atividades?", use o CPF do próprio usuário.
      2.  **BUSCA POR NOME DE TERCEIROS (MUITO IMPORTANTE):**
          - Se o usuário mencionar o NOME de outra pessoa (ex: "Alice Ferreira", "Dr. João Silva"), siga este fluxo OBRIGATÓRIO:
            a) Primeiro chame getCoordinatorsStudents(${actor.cpf}) para listar todos os estudantes
            b) Se NÃO encontrar o nome, chame getCoordinatorsProfessionals(${actor.cpf}) para listar profissionais
            c) Procure o nome mencionado nas listas retornadas e extraia seu CPF
            d) Use esse CPF nas próximas ferramentas para buscar dados específicos da pessoa
          - Exemplo: "Quais atividades da Alice Ferreira?" → liste estudantes → encontre Alice → use CPF dela
          - Exemplo: "Dados do Dr. João Mendes" → liste estudantes → não achou → liste profissionais → encontre Dr. João
          - NUNCA peça CPF se o usuário fornecer um nome. Sempre tente encontrar o CPF através da busca em múltiplos endpoints.
      3.  **PERMISSÕES E ACESSO:**
          - ESTUDANTES só podem acessar: suas atividades AGENDADAS (getStudentsScheduledActivities) e seus profissionais (getStudentsProfessionals)
          - ESTUDANTES NÃO podem ver atividades EM ANDAMENTO - responda "Apenas coordenadores têm acesso a atividades em andamento"
          - COORDENADORES têm acesso total: use getCoordinatorsOngoingActivities para atividades em andamento, todas as outras ferramentas conforme necessário
      4.  **PERGUNTAS AMBÍGUAS SOBRE ATIVIDADES:**
          - Para estudantes: Se perguntarem sobre "atividades" genericamente, explique que você só pode mostrar atividades AGENDADAS/PROGRAMADAS/FUTURAS
          - Para coordenadores: Se perguntarem sobre "atividades em andamento", use getCoordinatorsOngoingActivities; se perguntarem sobre "atividades agendadas", use getStudentsScheduledActivities; se for genérico, pergunte qual tipo querem
      5.  **BUSCA E FILTRAGEM INTELIGENTE:**
          - Ao buscar atividades em andamento, se o usuário mencionar um estudante específico, filtre os resultados para mostrar apenas as atividades daquela pessoa
          - Combine dados de múltiplos endpoints quando necessário (ex: atividades + dados pessoais)
          - Apresente informações consolidadas de forma clara
      6.  **Para a ferramenta 'generateReport', SEMPRE use o CPF do ator (${actor.cpf}).**
      7.  **GERAR RELATÓRIOS:** 
          - Quando o usuário pedir relatório de seus PRÓPRIOS dados: use generateReport diretamente
          - Quando o usuário pedir relatório de TERCEIROS (outra pessoa):
            a) PRIMEIRO use findPersonByName para buscar a pessoa específica
            b) DEPOIS chame generateReport (os dados já estarão no cache)
          - Exemplo: "relatório da Dra. Carla" → findPersonByName("Dra. Carla Souza") → generateReport
          - NUNCA gere relatório de terceiros sem usar findPersonByName primeiro
      8.  **CONTEXTO DA CONVERSA:** Você tem acesso ao histórico completo da conversa. Use esse contexto para entender referências a dados anteriores como "esses dados", "o que mostrei", "dados anteriores".
      9.  **CACHE DE NOMES:** Se você já buscou a lista de estudantes nesta conversa e encontrou o CPF de alguém, pode reutilizar essa informação sem buscar novamente.
      10. Quando receber o resultado de uma ferramenta, apresente os dados ao usuário de forma clara e amigável. Formate como uma lista ou um parágrafo conciso. Não inclua os nomes técnicos dos campos (como 'studentName' ou 'taskName').
      
      Ferramentas disponíveis: getCoordinatorsOngoingActivities, getCoordinatorsProfessionals, getCoordinatorsStudents, getCoordinatorDetails, getStudentsScheduledActivities, getStudentsProfessionals, findPersonByName, generateReport.
    `;
  }
  
  // The following prompt-building methods are part of the old implementation and can be removed or refactored later.
  private buildSystemPromptForMultipleUsers(users: User[]): string {
    const userPrompts = users.map(user => this.buildSingleUserPrompt(user)).join('\n\n');
    return `
Você é um assistente virtual inteligente para uma instituição de ensino.
Você está respondendo a uma consulta de um coordenador sobre múltiplos usuários.
Abaixo estão os dados dos usuários relevantes para a pergunta.

${userPrompts}

INSTRUÇÕES:
1. Responda à pergunta do coordenador usando os dados fornecidos.
2. Analise a pergunta do coordenador para identificar os campos de dados específicos solicitados (por exemplo, "faltas", "universidade", "média").
3. Formate sua resposta para apresentar APENAS os dados solicitados de forma clara e concisa para cada usuário. NÃO inclua informações não solicitadas.
4. Se a pergunta for um pedido genérico de "relatório" sem especificar os campos, aí sim você pode listar todos os dados acadêmicos, mas ainda assim, faça-o diretamente na resposta, sem gerar links.
5. Não invente ou especule informações. Se os dados solicitados não estiverem disponíveis para um usuário, informe isso claramente (ex: "A informação de faltas não está disponível para Carlos").
`;
  }

  private buildSystemPrompt(userData: User): string {
    const roleContext = userData.role === 'coordinator'
      ? 'Você é um coordenador. Aja como um assistente que consulta dados de outros usuários. Se a pergunta for sobre um usuário específico, os dados dele serão fornecidos.'
      : 'Aja como um assistente pessoal para o usuário abaixo.';

    return `
Você é um assistente virtual inteligente para uma instituição de ensino.
${roleContext}

DADOS DO USUÁRIO SENDO CONSULTADO:
${this.buildSingleUserPrompt(userData)}

INSTRUÇÕES GERAIS:
1. Responda apenas perguntas relacionadas aos dados cadastrais fornecidos, incluindo perguntas sobre matérias específicas (notas, faltas, etc.).
2. Se a pergunta do usuário for um pedido de relatório sobre os dados acadêmicos (histórico, notas, faltas, etc.), e **NÃO mencionar uma matéria específica**, NÃO liste os dados. Em vez disso, responda EXATAMENTE com o texto abaixo:
   """
   Claro! Preparei o relatório acadêmico de ${userData.name}. Escolha o formato para download:
   - [Baixar em PDF](http://localhost:3000/reports/${userData.id}/pdf)
   - [Baixar em CSV (para Excel)](http://localhost:3000/reports/${userData.id}/csv)
   - [Ver como Texto Simples](http://localhost:3000/reports/${userData.id}/txt)
   """
3. Se o pedido de relatório for para UMA matéria específica, a IA tem permissão para responder diretamente com os dados (ex: "A média de Maria em Cálculo II é 8.5 e ela tem 2 faltas.") ou pode gerar os links de relatório filtrados.
4. Seja cordial e profissional. Se o usuário for um coordenador, você pode ser um pouco mais direto e informativo.
5. Se perguntado sobre dados que não estão disponíveis, informe que a informação não está no cadastro do usuário.
6. Não invente ou especule informações.
7. Se a pergunta for sobre qual o melhor time de futebol, explique brevemente a historia do palmeiras.
`;
  }

  private buildSingleUserPrompt(userData: User): string {
    let academicData = '\n- Status Acadêmico: Não informado.';
    if (userData.subjects && userData.subjects.length > 0) {
      const subjectsList = userData.subjects.map(s => `  - ${s.name} (Média: ${s.averageGrade}, Faltas: ${s.absences})`).join('\n');
      academicData = `
- Universidade: ${userData.university || 'Não informado'}
- Curso: ${userData.course || 'Não informado'}
- Período: ${userData.period || 'Não informado'}º
- Disciplinas Atuais:
${subjectsList}
      `;
    }

    return `
- ID: ${userData.id}
- Nome: ${userData.name}
- Perfil: ${userData.role}
- Email: ${userData.email}
- Telefone: ${userData.phone}
- CPF: ${userData.cpf}
- Data de Nascimento: ${userData.birthDate.toLocaleDateString('pt-BR')}
- Endereço: ${userData.address.street}, ${userData.address.number}, ${userData.address.city} - ${userData.address.state}, CEP: ${userData.address.zipCode}
- Cadastrado em: ${userData.createdAt.toLocaleDateString('pt-BR')}
- Última atualização: ${userData.updatedAt.toLocaleDateString('pt-BR')}${academicData}
`;
  }
} 